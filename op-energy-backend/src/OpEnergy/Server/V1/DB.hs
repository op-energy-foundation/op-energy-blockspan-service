{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE EmptyDataDecls  #-}


module OpEnergy.Server.V1.DB where

import           Data.Pool
import qualified Data.Text.Show as T
import qualified Data.Text.Encoding as TE
import           Control.Monad.IO.Class (MonadIO, liftIO)
import           Control.Monad.IO.Unlift(MonadUnliftIO)
import           Control.Monad.Logger    (MonadLoggerIO )
import           Control.Monad.Trans.Reader (ReaderT)
import           Control.Monad.Logger    (NoLoggingT )
import           Control.Monad (forM_ )
import qualified Data.List as List

import           Database.Persist.Postgresql
import           Control.Monad.Trans.Resource(ResourceT)

import           Data.OpEnergy.API.V1.Natural(verifyNatural, fromNatural)
import           Data.OpEnergy.API.V1.Block
import           Data.OpEnergy.API.V1.Positive(fromPositive)
import           OpEnergy.Server.V1.Config
import           OpEnergy.Server.V1.DB.Migrations
import           OpEnergy.Server.V1.DB.Migrations.BlockHeaderAddChainreward
                   ( createInitialBlockHeaderChainreward
                   , fillBlockHeaderChainreward
                   , finalizeFilledBlockHeaderChainreward
                   )

-- | connect to DB. Returns connection pool
getConnection
  :: ( MonadLoggerIO m
     , MonadUnliftIO m
     , MonadIO m
     )
  => Config
  -> m (Pool SqlBackend)
getConnection config = do
  pool <- createPostgresqlPool
    connStr
    (fromPositive $ configDBConnectionPoolSize config)
  liftIO $ flip runSqlPersistMPool pool $ do
    -- print migrations to log the needed changes
    printMigration migrateBlockHeaderDB
    printMigration migrateBlock
    -- run custom migrations
    migrateBlockHeaderDBSchema config
    -- now run the automatic migrations to confirm schema compatibility
    runMigration migrateBlockHeaderDB
    runMigration migrateBlock -- perform necessary migrations. currently only BlockHeader table's migrations
  return pool
  where
    connStr = TE.encodeUtf8
      $! "host=" <> configDBHost config
      <> " port=" <> (T.tshow $ configDBPort config)
      <> " user=" <> configDBUser config
      <> " dbname=" <> configDBName config
      <> " password=" <> configDBPassword config

-- | this list contains our custom migrations that can't be generated by persistent, like initial calculating of aggregated fields' values
-- NOTE: this list have to be append only. It is your responsibility to not to delete or change the list after merge. ONLY APPENDS ARE ALLOWED
-- after running each migration DB version is being increased automatically and transaction being commited. Each migration is running in a separate transcation.
-- NOTE: it is expected, that migrations will be idempotent
-- NOTE: if there should be a schema downgrade, it is expected, that "wrong" schema migration
-- will become 'return ()' and the next migration will perform check of migration requirement
-- and downgrade in case
blockHeaderDBMigrations :: [( Config -> ReaderT
                                  SqlBackend
                                  (Control.Monad.Logger.NoLoggingT
                                   (ResourceT IO)
                                  )
                                  ()
                                )
                               ]
blockHeaderDBMigrations =
  [ createInitialBlockHeaderChainreward
  , fillBlockHeaderChainreward
  , finalizeFilledBlockHeaderChainreward
  ]

-- | custom migration procedure
-- for now, it is expected, that each migration have no clue about db version and thus none
-- of individual migration can affect on the order of the migrations, so there is no way
-- to just to increase version not by 1
migrateBlockHeaderDBSchema
  :: Config
  -> ReaderT
       SqlBackend
       (NoLoggingT
        (ResourceT IO)
       )
       ()
migrateBlockHeaderDBSchema config = do
  runMigration migrateBlockHeaderDB -- ensure, that there should exist version-tacing table
  transactionSave -- commit everything, that happend before we start

  let
      dbVersionAfterMigrations = List.length blockHeaderDBMigrations
  (currentDBVersion, currentDBVersionId) <- do -- try to get latest applied
                                               -- migrations' version
    mrecord <- selectFirst [] []
    case mrecord of
      Just (Entity currentDBVersionId record)-> return (blockHeaderDBVersion record, currentDBVersionId)
      Nothing -> do -- fallback to default version of 0
        (mBlockHeaderTableExistButVersionUnknown::[Single Bool]) <- rawSql
          "SELECT EXISTS (SELECT FROM information_schema.tables where table_name = ? and table_schema='public');"
          [ PersistText $! unEntityNameDB (tableDBName (undefined :: BlockHeader))]
        let
            currentDBVersion = case mBlockHeaderTableExistButVersionUnknown of
              ((Single True):_)  -> needToApplyCustomMigrations
                where
                  needToApplyCustomMigrations = 0
              ((Single False):_)  -> latestSchemaWillBeCreatedByORM
                where
                latestSchemaWillBeCreatedByORM = verifyNatural dbVersionAfterMigrations
              _ -> error ("migrateBlockHeaderDBSchema: got unexpected response from DB: " ++ show mBlockHeaderTableExistButVersionUnknown)
        currentDBVersionId <- insert $ BlockHeaderDB
          { blockHeaderDBVersion = currentDBVersion
          }
        return (currentDBVersion, currentDBVersionId)
  let
      unAppliedMigrations = List.drop (fromNatural currentDBVersion) blockHeaderDBMigrations
  if dbVersionAfterMigrations < fromNatural currentDBVersion
    then do
      let msg = "migrateBlockHeaderDBSchema: unsupported DB schema " ++ show currentDBVersion ++ ", supported DB version up to: " ++ show dbVersionAfterMigrations
      error msg
    else do
      forM_ unAppliedMigrations $ \migration -> do
        migration config -- call the actual migration procedure
        update currentDBVersionId
          [ BlockHeaderDBVersion +=. verifyNatural 1
          ]
        transactionSave -- keep each migration as one transaction to keep db at the latest successful migration

